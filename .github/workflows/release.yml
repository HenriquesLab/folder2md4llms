name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install UV
      uses: astral-sh/setup-uv@v4
      with:
        version: "latest"
        enable-cache: true

    - name: Install Rye
      uses: eifinger/setup-rye@v4
      with:
        enable-cache: true

    - name: Install dependencies
      run: uv sync --group dev

    - name: Get version
      id: version
      run: |
        VERSION=$(uv run python -c "from folder2md4llms.__version__ import __version__; print(__version__)")
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Package version: $VERSION"

    - name: Run tests
      run: uv run pytest -x --tb=short

    - name: Build package
      run: |
        echo "::group::Building package"
        rye build
        echo "::endgroup::"

        echo "::group::Validate package"
        uv pip install twine
        uv run python -m twine check dist/*
        echo "::endgroup::"

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: dist-packages
        path: dist/
        retention-days: 30

  test-pypi:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: build
    environment: test-pypi

    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: dist-packages
        path: dist/

    - name: Publish to TestPyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        repository-url: https://test.pypi.org/legacy/
        password: ${{ secrets.TESTPYPI_TOKEN }}

    - name: Test installation from TestPyPI
      run: |
        echo "Waiting for package to be available on TestPyPI..."
        sleep 60

        python -m pip install --upgrade pip

        # Retry logic for TestPyPI installation
        MAX_ATTEMPTS=5
        ATTEMPT=1
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Attempt $ATTEMPT of $MAX_ATTEMPTS to install from TestPyPI..."

          if python -m pip install -i https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ folder2md4llms==${{ needs.build.outputs.version }}; then
            echo "Successfully installed from TestPyPI"
            break
          else
            echo "Installation failed, attempt $ATTEMPT of $MAX_ATTEMPTS"
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "All attempts failed, exiting"
              exit 1
            fi
            echo "Waiting 30 seconds before retry..."
            sleep 30
            ATTEMPT=$((ATTEMPT + 1))
          fi
        done

        # Test basic functionality
        folder2md --version
        echo "# Test" > test.md
        folder2md . --output test_output.md
        test -f test_output.md

  pypi:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [build, test-pypi]
    environment: pypi
    if: github.ref_type == 'tag'

    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: dist-packages
        path: dist/

    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        password: ${{ secrets.PYPI_TOKEN }}

    - name: Test installation from PyPI
      run: |
        echo "Waiting for package to be available on PyPI..."
        sleep 120

        python -m pip install --upgrade pip

        # Retry logic for PyPI installation
        MAX_ATTEMPTS=5
        ATTEMPT=1
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Attempt $ATTEMPT of $MAX_ATTEMPTS to install from PyPI..."

          if python -m pip install folder2md4llms==${{ needs.build.outputs.version }}; then
            echo "Successfully installed from PyPI"
            break
          else
            echo "Installation failed, attempt $ATTEMPT of $MAX_ATTEMPTS"
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "All attempts failed, exiting"
              exit 1
            fi
            echo "Waiting 60 seconds before retry..."
            sleep 60
            ATTEMPT=$((ATTEMPT + 1))
          fi
        done

        # Test basic functionality
        folder2md --version
        echo "# Test" > test.md
        folder2md . --output test_output.md
        test -f test_output.md

  build-binaries:
    runs-on: ubuntu-latest
    needs: [build, pypi]
    if: github.ref_type == 'tag' && success()
    timeout-minutes: 20

    steps:
    - name: Trigger binary builds
      run: |
        echo "Triggering binary builds for version ${{ needs.build.outputs.version }}"

        # Trigger the build-binaries workflow
        response=$(curl -s -w "%{http_code}" -X POST \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build-binaries.yml/dispatches" \
          -d "{\"ref\":\"${{ github.ref_name }}\",\"inputs\":{\"version\":\"${{ needs.build.outputs.version }}\"}}")

        http_code=${response: -3}

        if [ "$http_code" -eq 204 ]; then
          echo "✅ Successfully triggered binary builds"
        else
          echo "❌ Failed to trigger binary builds (HTTP $http_code)"
          echo "Response: ${response%???}"
          exit 1
        fi

  update-submodules:
    runs-on: ubuntu-latest
    needs: [build, pypi, build-binaries]
    if: github.ref_type == 'tag' && success()
    timeout-minutes: 10

    steps:
    - name: Wait for binary builds to complete
      run: |
        echo "Waiting for binary builds to complete..."

        # Wait up to 10 minutes for binary builds
        MAX_WAIT=600
        WAIT_TIME=0
        SLEEP_INTERVAL=30

        while [ $WAIT_TIME -lt $MAX_WAIT ]; do
          # Check the status of the build-binaries workflow
          RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build-binaries.yml/runs?per_page=5")

          # Get the most recent run that matches our tag
          LATEST_RUN_STATUS=$(echo "$RUNS" | jq -r --arg tag "${{ github.ref_name }}" \
            '.workflow_runs[] | select(.head_branch == $tag) | .status' | head -1)

          LATEST_RUN_CONCLUSION=$(echo "$RUNS" | jq -r --arg tag "${{ github.ref_name }}" \
            '.workflow_runs[] | select(.head_branch == $tag) | .conclusion' | head -1)

          echo "Binary build status: $LATEST_RUN_STATUS, conclusion: $LATEST_RUN_CONCLUSION"

          if [ "$LATEST_RUN_STATUS" = "completed" ]; then
            if [ "$LATEST_RUN_CONCLUSION" = "success" ]; then
              echo "✅ Binary builds completed successfully"
              break
            else
              echo "❌ Binary builds failed with conclusion: $LATEST_RUN_CONCLUSION"
              echo "Continuing with submodule updates anyway..."
              break
            fi
          fi

          echo "Binary builds still running, waiting ${SLEEP_INTERVAL}s..."
          sleep $SLEEP_INTERVAL
          WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
        done

        if [ $WAIT_TIME -ge $MAX_WAIT ]; then
          echo "⚠️ Timeout waiting for binary builds, continuing with submodule updates"
        fi

    - name: Trigger submodule updates
      run: |
        echo "Triggering updates for package version ${{ needs.build.outputs.version }}"

        # Function to dispatch with error handling
        dispatch_update() {
          local repo=$1
          local repo_name=$(basename $repo)

          echo "Triggering update for $repo_name..."
          response=$(curl -s -w "%{http_code}" -X POST \
            -H "Authorization: token ${{ secrets.DISPATCH_PAT }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$repo/dispatches" \
            -d "{\"event_type\":\"new_release\",\"client_payload\":{\"version\":\"${{ needs.build.outputs.version }}\",\"tag\":\"v${{ needs.build.outputs.version }}\"}}")

          http_code=${response: -3}

          if [ "$http_code" -eq 204 ]; then
            echo "✅ Successfully triggered update for $repo_name"
          else
            echo "❌ Failed to trigger update for $repo_name (HTTP $http_code)"
            echo "Response: ${response%???}"
            return 1
          fi
        }

        # Dispatch updates with error handling
        dispatch_update "HenriquesLab/homebrew-folder2md4llms" || echo "Warning: Homebrew update failed"
        dispatch_update "HenriquesLab/scoop-folder2md4llms" || echo "Warning: Scoop update failed"

        echo "Repository dispatch completed"
